<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Abracadabra — Predictive Coding</title>
<link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #07080f;
    --panel: #0c0e18;
    --border: #1a2040;
    --accent: #a78bfa;
    --accent2: #ff6b35;
    --accent3: #00ffe0;
    --accent4: #f59e0b;
    --text: #7888aa;
    --text-bright: #c8d4ee;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    color: var(--text-bright);
    font-family: 'Share Tech Mono', monospace;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 28px 16px 48px;
  }

  body::before {
    content: '';
    position: fixed; inset: 0;
    background:
      radial-gradient(ellipse at 10% 10%, rgba(167,139,250,0.04) 0%, transparent 55%),
      radial-gradient(ellipse at 90% 90%, rgba(0,255,224,0.03) 0%, transparent 55%);
    pointer-events: none;
  }

  h1 {
    font-family: 'Orbitron', monospace;
    font-size: clamp(1rem, 3vw, 1.55rem);
    font-weight: 900;
    color: var(--accent);
    letter-spacing: 0.15em;
    text-align: center;
    margin-bottom: 4px;
    text-shadow: 0 0 24px rgba(167,139,250,0.45);
  }

  .subtitle {
    font-size: 0.7rem;
    color: var(--text);
    letter-spacing: 0.1em;
    margin-bottom: 22px;
    text-align: center;
  }

  .main {
    width: 100%;
    max-width: 1000px;
    display: flex;
    flex-direction: column;
    gap: 13px;
  }

  .controls {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 14px 20px;
    display: flex;
    flex-wrap: wrap;
    gap: 14px 22px;
    align-items: flex-end;
  }

  .ctrl-group { display: flex; flex-direction: column; gap: 5px; }

  .ctrl-group label {
    font-size: 0.61rem;
    color: var(--text);
    letter-spacing: 0.1em;
    text-transform: uppercase;
  }

  .ctrl-group input[type=range] {
    -webkit-appearance: none;
    width: 115px; height: 3px;
    background: var(--border);
    border-radius: 2px;
    outline: none;
  }

  .ctrl-group input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 13px; height: 13px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    box-shadow: 0 0 8px rgba(167,139,250,0.6);
  }

  .ctrl-group .val {
    font-size: 0.78rem;
    color: var(--accent);
    min-width: 22px;
    display: inline-block;
  }

  .ctrl-group input[type=text] {
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 4px;
    color: var(--accent);
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.88rem;
    padding: 4px 10px;
    width: 175px;
    letter-spacing: 0.1em;
    outline: none;
  }

  .ctrl-group input[type=text]:focus {
    border-color: var(--accent);
    box-shadow: 0 0 8px rgba(167,139,250,0.2);
  }

  .btn {
    font-family: 'Orbitron', monospace;
    font-size: 0.66rem;
    letter-spacing: 0.12em;
    padding: 8px 15px;
    border-radius: 4px;
    border: 1px solid var(--accent);
    background: transparent;
    color: var(--accent);
    cursor: pointer;
    transition: all 0.2s;
    text-transform: uppercase;
  }

  .btn:hover { background: rgba(167,139,250,0.1); box-shadow: 0 0 12px rgba(167,139,250,0.25); }
  .btn.stop { border-color: var(--accent2); color: var(--accent2); }
  .btn.stop:hover { background: rgba(255,107,53,0.1); }
  .btn.regen { border-color: var(--accent3); color: var(--accent3); }
  .btn.regen:hover { background: rgba(0,255,224,0.08); }

  /* ── Sensor + sequence display ── */
  .seq-wrap {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 14px 18px;
  }

  .section-label {
    font-size: 0.6rem;
    color: var(--text);
    letter-spacing: 0.14em;
    text-transform: uppercase;
    margin-bottom: 10px;
  }

  #seqRow {
    display: flex;
    gap: 3px;
    align-items: flex-end;
    overflow-x: auto;
    padding-bottom: 4px;
  }

  .seq-cell {
    min-width: 32px;
    height: 42px;
    border-radius: 4px;
    border: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 2px;
    flex-shrink: 0;
    transition: all 0.12s;
    position: relative;
  }

  .seq-cell .sym {
    font-size: 0.88rem;
    font-weight: bold;
    color: var(--text);
  }

  .seq-cell .pos {
    font-size: 0.52rem;
    color: var(--border);
  }

  /* states */
  .seq-cell.past { opacity: 0.38; }
  .seq-cell.in-sensor {
    border-color: rgba(167,139,250,0.5);
    background: rgba(167,139,250,0.07);
  }
  .seq-cell.in-sensor .sym { color: var(--accent); }
  .seq-cell.sensor-front {
    border-color: var(--accent);
    box-shadow: 0 0 10px rgba(167,139,250,0.35);
  }
  .seq-cell.sensor-front .sym { color: #fff; }
  .seq-cell.future { opacity: 0.18; }
  .seq-cell.infer-fired {
    border-color: var(--accent3);
    background: rgba(0,255,224,0.07);
  }
  .seq-cell.infer-fired .sym { color: var(--accent3); }

  /* sensor bracket label */
  #sensorBracket {
    font-size: 0.6rem;
    color: var(--accent);
    letter-spacing: 0.08em;
    margin-top: 6px;
    min-height: 16px;
  }

  /* ── Network canvas ── */
  .net-wrap {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 14px;
    position: relative;
  }

  canvas#netCanvas {
    display: block;
    width: 100%;
    border-radius: 4px;
  }

  .predict-banner {
    position: absolute;
    top: 10px; right: 14px;
    font-family: 'Orbitron', monospace;
    font-size: 0.68rem;
    letter-spacing: 0.12em;
    padding: 5px 13px;
    border-radius: 4px;
    border: 1px solid transparent;
    opacity: 0;
    transition: opacity 0.3s;
  }

  .predict-banner.show { opacity: 1; }
  .predict-banner.tp  { border-color: var(--accent3); color: var(--accent3); background: rgba(0,255,224,0.07); }
  .predict-banner.fp  { border-color: var(--accent2); color: var(--accent2); background: rgba(255,107,53,0.07); }
  .predict-banner.fn  { border-color: var(--accent4); color: var(--accent4); background: rgba(245,158,11,0.07); }

  /* ── Latent node sustain bars ── */
  .sustain-wrap {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 13px 18px;
  }

  #sustainBars { display: flex; flex-direction: column; gap: 7px; margin-top: 6px; }

  .sustain-row { display: flex; align-items: center; gap: 10px; }

  .sustain-name {
    font-size: 0.64rem;
    color: var(--text);
    width: 90px;
    letter-spacing: 0.05em;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .sustain-track {
    flex: 1;
    height: 9px;
    background: var(--border);
    border-radius: 5px;
    overflow: hidden;
  }

  .sustain-fill {
    height: 100%;
    border-radius: 5px;
    background: var(--accent);
    transition: width 0.1s;
  }

  .sustain-fill.live { background: var(--accent3); box-shadow: 0 0 7px rgba(0,255,224,0.5); }

  /* ── Stats ── */
  .stats { display: flex; gap: 10px; flex-wrap: wrap; }

  .stat-box {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 10px 15px;
    flex: 1;
    min-width: 110px;
  }

  .stat-box .label {
    font-size: 0.57rem;
    color: var(--text);
    letter-spacing: 0.12em;
    text-transform: uppercase;
    margin-bottom: 4px;
  }

  .stat-box .value {
    font-family: 'Orbitron', monospace;
    font-size: 1.25rem;
    color: var(--accent);
  }

  .stat-box.fp .value  { color: var(--accent2); }
  .stat-box.early .value { color: var(--accent3); }
  .stat-box.fn .value  { color: var(--accent4); }

  /* ── Log ── */
  .log-wrap {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 10px 15px;
    height: 88px;
    overflow-y: auto;
    font-size: 0.66rem;
    color: var(--text);
    line-height: 1.75;
  }

  .log-wrap .entry { border-bottom: 1px solid rgba(255,255,255,0.03); padding: 1px 0; }
  .log-wrap .tp    { color: var(--accent3); }
  .log-wrap .fp    { color: var(--accent2); }
  .log-wrap .fn    { color: var(--accent4); }
  .log-wrap .early { color: var(--accent); }
  .log-wrap .sep   { color: var(--border); }
</style>
</head>
<body>

<h1>ABRACADABRA — PREDICTIVE CODING</h1>
<p class="subtitle">sustained latent firing · partial evidence threshold · early prediction on sparse manifolds</p>

<div class="main">

  <!-- Controls -->
  <div class="controls">
    <div class="ctrl-group">
      <label>Target Sequence</label>
      <input type="text" id="targetSeq" value="ABRACADABRA" maxlength="16">
    </div>
    <div class="ctrl-group">
      <label>Sensor Width <span class="val" id="sensorWidthVal">5</span></label>
      <input type="range" id="sensorWidth" min="3" max="11" value="5">
    </div>
    <div class="ctrl-group">
      <label>Fanin <span class="val" id="faninVal">5</span></label>
      <input type="range" id="fanin" min="2" max="9" value="5">
    </div>
    <div class="ctrl-group">
      <label>Latent Nodes <span class="val" id="nodeCountVal">3</span></label>
      <input type="range" id="nodeCount" min="2" max="7" value="3">
    </div>
    <div class="ctrl-group">
      <label>Min Nodes to Infer (K) <span class="val" id="kInferVal">3</span></label>
      <input type="range" id="kInfer" min="1" max="7" value="3">
    </div>
    <div class="ctrl-group">
      <label>Sustain (strides) <span class="val" id="sustainVal">7</span></label>
      <input type="range" id="sustain" min="1" max="20" value="7">
    </div>
    <div class="ctrl-group">
      <label>Speed <span class="val" id="speedVal">4</span></label>
      <input type="range" id="speed" min="1" max="10" value="4">
    </div>
    <div class="ctrl-group">
      <label>Series <span class="val" id="seriesVal">60</span></label>
      <input type="range" id="seriesLen" min="10" max="300" value="60" step="5">
    </div>
    <div style="display:flex;gap:8px;align-items:flex-end;">
      <button class="btn" id="btnStart">▶ Run</button>
      <button class="btn stop" id="btnStop">■ Stop</button>
      <button class="btn regen" id="btnRegen">⟳ Rewire</button>
    </div>
  </div>

  <!-- Sequence + sensor display -->
  <div class="seq-wrap">
    <div class="section-label">Input Stream — Sliding Sensor Window</div>
    <div id="seqRow"></div>
    <div id="sensorBracket"></div>
  </div>

  <!-- Network -->
  <div class="net-wrap">
    <canvas id="netCanvas" height="260"></canvas>
    <div class="predict-banner" id="predictBanner">—</div>
  </div>

  <!-- Sustain bars -->
  <div class="sustain-wrap">
    <div class="section-label">Latent Node Sustain</div>
    <div id="sustainBars"></div>
  </div>

  <!-- Stats -->
  <div class="stats">
    <div class="stat-box">
      <div class="label">Sequences</div>
      <div class="value" id="statTotal">0</div>
    </div>
    <div class="stat-box early">
      <div class="label">Early Fires</div>
      <div class="value" id="statEarly">0</div>
    </div>
    <div class="stat-box">
      <div class="label">Full TP</div>
      <div class="value" id="statTP">0</div>
    </div>
    <div class="stat-box fp">
      <div class="label">False Pos</div>
      <div class="value" id="statFP">0</div>
    </div>
    <div class="stat-box fn">
      <div class="label">False Neg</div>
      <div class="value" id="statFN">0</div>
    </div>
    <div class="stat-box early">
      <div class="label">Avg Fire Stride</div>
      <div class="value" id="statAvgStride">—</div>
    </div>
  </div>

  <!-- Log -->
  <div class="log-wrap" id="logWrap"></div>

</div>

<script>
// ════════════════════════════════════════════════════════
//  STATE
// ════════════════════════════════════════════════════════
let target     = 'ABRACADABRA';
let grades     = [];      // unique symbols
let gradeMap   = {};      // symbol → index
let seqLen     = 0;

let latentNodes   = [];   // {pattern:[], label:'', sustainLeft:0}
// latentNodes[i].pattern is an array of grade-indices, length = fanin
// matched against the LEFT-aligned portion of the sensor window
// (sparse demo: sensor wider than fanin → only first fanin slots checked)

let sustainLevels = [];

// Current run
let running          = false;
let timer            = null;
let currentSeq       = [];   // grade indices, length seqLen
let isTargetSeq      = false;
let currentStride    = 0;    // leading edge of sensor window
let inferFiredStride = -1;

// Series
let seriesDone  = 0;
let seriesTotal = 0;

// Stats
let stats = {total:0, early:0, tp:0, fp:0, fn:0, fireStrides:[]};

// ════════════════════════════════════════════════════════
//  INIT / BUILD
// ════════════════════════════════════════════════════════
function init() {
  target   = document.getElementById('targetSeq').value.toUpperCase().trim() || 'ABRACADABRA';
  grades   = [...new Set(target.split(''))];
  gradeMap = {};
  grades.forEach((g,i) => gradeMap[g] = i);
  seqLen   = target.length;

  buildLatentNodes();
  buildSustainBars();
  renderSeqRow([]);
  drawNetwork([], [], false);
  resetStats();
}

function buildLatentNodes() {
  const n      = parseInt(document.getElementById('nodeCount').value);
  const fanin  = Math.min(parseInt(document.getElementById('fanin').value), seqLen);

  // Generate n evenly-spaced consecutive subpatterns of the target.
  // Each is a substring of length=fanin, start positions spread across the target.
  latentNodes = [];
  for (let i = 0; i < n; i++) {
    const maxStart = seqLen - fanin;
    const start    = Math.round((maxStart * i) / Math.max(n - 1, 1));
    const pat      = [];
    for (let j = 0; j < fanin; j++) pat.push(gradeMap[target[start + j]]);
    latentNodes.push({
      pattern: pat,
      label:   target.slice(start, start + fanin),
      startPos: start        // absolute position in target where this subpattern lives
    });
  }
  sustainLevels = new Array(latentNodes.length).fill(0);
}

function buildSustainBars() {
  const bars = document.getElementById('sustainBars');
  bars.innerHTML = '';
  latentNodes.forEach((node, i) => {
    const row = document.createElement('div');
    row.className = 'sustain-row';
    row.innerHTML = `
      <div class="sustain-name" title="${node.label}">${node.label}</div>
      <div class="sustain-track">
        <div class="sustain-fill" id="sbar_${i}" style="width:0%"></div>
      </div>`;
    bars.appendChild(row);
  });
}

// ════════════════════════════════════════════════════════
//  SEQUENCE ROW
// ════════════════════════════════════════════════════════
function renderSeqRow(seq) {
  const row = document.getElementById('seqRow');
  row.innerHTML = '';
  const sw = sensorWidth();
  for (let i = 0; i < seqLen; i++) {
    const cell = document.createElement('div');
    cell.className = 'seq-cell future';
    cell.id = `sc_${i}`;
    const sym = seq.length > i ? grades[seq[i]] : (target[i] || '·');
    cell.innerHTML = `<div class="sym">${sym}</div><div class="pos">${i}</div>`;
    row.appendChild(cell);
  }
}

function updateSeqRow(seq, stride) {
  const sw      = sensorWidth();
  const winStart = Math.max(0, stride - sw + 1);
  const winEnd   = stride; // inclusive, stride = front of window

  for (let i = 0; i < seqLen; i++) {
    const cell = document.getElementById(`sc_${i}`);
    if (!cell) continue;
    const sym = seq.length > i ? grades[seq[i]] : '·';
    cell.querySelector('.sym').textContent = sym;

    let cls = 'seq-cell ';
    if (i < winStart)        cls += 'past';
    else if (i === stride)   cls += 'sensor-front in-sensor';
    else if (i <= winEnd)    cls += 'in-sensor';
    else if (i > stride && inferFiredStride >= 0 && i <= inferFiredStride) cls += 'infer-fired';
    else                     cls += 'future';
    cell.className = cls;
  }

  // Bracket label
  const bracket = document.getElementById('sensorBracket');
  const winContent = seq.slice(winStart, stride + 1).map(g => grades[g]).join('');
  bracket.textContent = `sensor [${winStart}..${stride}] = "${winContent}"  (width ${sw}, fanin ${faninVal()})`;
}

// ════════════════════════════════════════════════════════
//  PROCESS ONE STRIDE
// ════════════════════════════════════════════════════════
function sensorWidth() { return parseInt(document.getElementById('sensorWidth').value); }
function faninVal()    { return Math.min(parseInt(document.getElementById('fanin').value), seqLen); }
function sustainParam(){ return parseInt(document.getElementById('sustain').value); }
function kInferParam() {
  const n = parseInt(document.getElementById('nodeCount').value);
  return Math.min(parseInt(document.getElementById('kInfer').value), n);
}

function processStride(seq, stride) {
  const sw      = sensorWidth();
  const fanin   = fadinVal2();
  const sustain = sustainParam();

  // Window: the last sw symbols up to and including current stride
  const winStart = Math.max(0, stride - sw + 1);
  const window   = seq.slice(winStart, stride + 1); // length 1..sw

  // Step 1: decay existing sustain
  sustainLevels = sustainLevels.map(s => Math.max(0, s - 1));

  // Step 2: check each latent node
  // A node matches when the window has just fully covered its subpattern.
  // That happens when: stride === node.startPos + fanin - 1
  // (the last symbol of its pattern just entered the window front)
  // We also require the window actually contains those positions.
  latentNodes.forEach((node, i) => {
    const patEnd = node.startPos + fanin - 1; // last absolute position of this pattern
    if (stride === patEnd) {
      // Check: seq[node.startPos .. node.startPos+fanin-1] matches node.pattern
      const match = node.pattern.every((g, j) => seq[node.startPos + j] === g);
      if (match) {
        sustainLevels[i] = sustain;
      }
    }
  });

  // Step 3: inference — K or more latent nodes alive simultaneously?
  const latentActive   = sustainLevels.map(s => s > 0);
  const activeCount    = latentActive.filter(Boolean).length;
  const k              = kInferParam();
  const inferenceFired = activeCount >= k;

  return { latentActive, inferenceFired, activeCount, window, winStart };
}

// small wrapper to avoid shadowing
function fadinVal2() { return faninVal(); }

// ════════════════════════════════════════════════════════
//  DRAW NETWORK
// ════════════════════════════════════════════════════════
function drawNetwork(latentActive, window, inferenceFired) {
  const canvas = document.getElementById('netCanvas');
  const W      = canvas.offsetWidth;
  canvas.width = W;
  canvas.height = 260;
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, W, 260);

  const sw     = sensorWidth();
  const fanin  = fadinVal2();
  const lCount = latentNodes.length;

  // Y positions
  const sensorY = 210;
  const latentY = 120;
  const inferY  = 38;

  // X positions — sensor nodes
  const sensorXs = Array.from({length: sw}, (_, i) => W * (i + 0.5) / sw);
  // latent nodes
  const latentXs = lCount === 1 ? [W/2] :
    Array.from({length: lCount}, (_, i) => W*0.12 + W*0.76*i/(lCount-1));
  const inferX = W / 2;

  const Rs  = Math.min(18, (W / sw) * 0.38);
  const Rl  = 20;
  const Ri2 = 24;

  // ── Wires: sensor → latent ──
  // Each latent node's pattern occupies specific absolute positions.
  // In the sensor window, its pattern slots map to window positions:
  // window[k] = seq[winStart + k], and node.startPos maps to window offset = node.startPos - winStart
  latentNodes.forEach((node, li) => {
    const active = latentActive[li];
    for (let j = 0; j < sw; j++) {
      if (j >= sensorXs.length) break;
      const isFaninSlot = j < fanin;
      // Is this window slot part of this node's pattern?
      const absPos = (window.length > 0) ? (currentStride - sw + 1 + j) : j;
      const isNodeSlot = (j < fanin); // first fanin slots are the "active" receptive field
      ctx.beginPath();
      ctx.moveTo(sensorXs[j], sensorY - Rs);
      ctx.lineTo(latentXs[li], latentY + Rl);
      if (isNodeSlot) {
        ctx.strokeStyle = active ? 'rgba(167,139,250,0.55)' : 'rgba(26,32,64,0.55)';
        ctx.lineWidth = active ? 1.5 : 0.7;
        ctx.setLineDash([]);
      } else {
        ctx.strokeStyle = 'rgba(20,26,55,0.3)';
        ctx.lineWidth = 0.5;
        ctx.setLineDash([3,5]);
      }
      ctx.stroke();
      ctx.setLineDash([]);
    }
  });

  // ── Wires: latent → infer ──
  latentNodes.forEach((_, li) => {
    const active = latentActive[li];
    ctx.beginPath();
    ctx.moveTo(latentXs[li], latentY - Rl);
    ctx.lineTo(inferX, inferY + Ri2);
    ctx.strokeStyle = active ? 'rgba(167,139,250,0.55)' : 'rgba(26,32,64,0.7)';
    ctx.lineWidth = active ? 1.5 : 0.7;
    ctx.stroke();
  });

  // ── Sensor nodes ──
  sensorXs.forEach((x, j) => {
    const sym        = window.length > j ? grades[window[j]] : '·';
    const isFaninSlot = j < fanin;
    const anyActive  = latentActive.some(Boolean);
    const matched    = anyActive && window.length > j &&
                       latentNodes.some((n, li) => latentActive[li] && j < n.pattern.length && window[j] === n.pattern[j]);

    ctx.beginPath();
    ctx.arc(x, sensorY, Rs, 0, Math.PI*2);
    ctx.fillStyle = matched
      ? 'rgba(167,139,250,0.15)'
      : (isFaninSlot ? 'rgba(255,255,255,0.03)' : 'rgba(10,12,30,0.6)');
    ctx.fill();
    ctx.strokeStyle = matched ? '#a78bfa'
      : (isFaninSlot ? '#2a3560' : '#141828');
    ctx.lineWidth = matched ? 1.8 : (isFaninSlot ? 1 : 0.5);
    ctx.stroke();

    ctx.fillStyle = matched ? '#c4b5fd' : (isFaninSlot ? '#556080' : '#232840');
    ctx.font = `bold ${Math.max(9, Rs*0.78)}px Share Tech Mono`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(sym, x, sensorY);

    ctx.fillStyle = isFaninSlot ? '#2a3560' : '#161a30';
    ctx.font = '8px Share Tech Mono';
    ctx.fillText(j, x, sensorY + Rs + 8);
  });

  // ── Latent nodes ──
  latentXs.forEach((x, li) => {
    const active    = latentActive[li];
    const sustPct   = sustainParam() > 0 ? sustainLevels[li] / sustainParam() : 0;

    ctx.beginPath();
    ctx.arc(x, latentY, Rl, 0, Math.PI*2);
    ctx.fillStyle = active ? `rgba(167,139,250,${0.08 + sustPct*0.18})` : 'rgba(14,16,34,0.8)';
    ctx.fill();
    ctx.strokeStyle = active ? '#a78bfa' : '#1a2040';
    ctx.lineWidth   = active ? 2 : 1;
    ctx.stroke();

    if (active) {
      ctx.beginPath();
      ctx.arc(x, latentY, Rl + 5, 0, Math.PI*2);
      ctx.strokeStyle = `rgba(167,139,250,${sustPct * 0.28})`;
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    ctx.fillStyle = active ? '#c4b5fd' : '#2a3465';
    ctx.font = 'bold 9px Share Tech Mono';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(latentNodes[li].label.slice(0,6), x, latentY);
  });

  // ── Inference node ──
  const isTp    = isTargetSeq;
  const iColor  = inferenceFired ? (isTp ? '#00ffe0' : '#ff6b35') : '#1a2040';
  ctx.beginPath();
  ctx.arc(inferX, inferY, Ri2, 0, Math.PI*2);
  ctx.fillStyle = inferenceFired
    ? (isTp ? 'rgba(0,255,224,0.13)' : 'rgba(255,107,53,0.13)')
    : 'rgba(14,16,34,0.8)';
  ctx.fill();
  ctx.strokeStyle = iColor;
  ctx.lineWidth   = inferenceFired ? 2.5 : 1;
  ctx.stroke();

  if (inferenceFired) {
    ctx.beginPath();
    ctx.arc(inferX, inferY, Ri2 + 7, 0, Math.PI*2);
    ctx.strokeStyle = isTp ? 'rgba(0,255,224,0.18)' : 'rgba(255,107,53,0.18)';
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  ctx.fillStyle = inferenceFired ? iColor : '#2a3465';
  ctx.font = 'bold 8px Orbitron';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  const kLabel = `${kInferParam()}/${latentNodes.length}`;
  ctx.fillText(`INFER ${kLabel}`, inferX, inferY);

  // ── Layer labels ──
  ctx.fillStyle = '#1e2850';
  ctx.font = '9px Share Tech Mono';
  ctx.textAlign = 'left';
  ctx.fillText(`SENSOR WINDOW  [width=${sw}, fanin=${fanin}]`, 6, sensorY - Rs - 9);
  ctx.fillText('LATENT AND-NODES  (subpattern detectors)', 6, latentY - Rl - 9);
  ctx.fillText('INFERENCE', 6, inferY - Ri2 - 7);

  ctx.fillStyle = '#3a4878';
  ctx.font = '10px Share Tech Mono';
  ctx.textAlign = 'right';
  ctx.fillText(`stride ${currentStride} / ${seqLen - 1}`, W - 8, inferY - Ri2 - 7);
}

// ════════════════════════════════════════════════════════
//  SUSTAIN BARS
// ════════════════════════════════════════════════════════
function updateSustainBars(latentActive) {
  const max = sustainParam();
  sustainLevels.forEach((s, i) => {
    const bar = document.getElementById(`sbar_${i}`);
    if (!bar) return;
    bar.style.width = (max > 0 ? s / max * 100 : 0) + '%';
    bar.className = 'sustain-fill' + (latentActive[i] ? ' live' : '');
  });
}

// ════════════════════════════════════════════════════════
//  STATS & LOG
// ════════════════════════════════════════════════════════
function resetStats() {
  stats = {total:0, early:0, tp:0, fp:0, fn:0, fireStrides:[]};
  updateStats();
  document.getElementById('logWrap').innerHTML = '';
}

function updateStats() {
  document.getElementById('statTotal').textContent    = stats.total;
  document.getElementById('statEarly').textContent    = stats.early;
  document.getElementById('statTP').textContent       = stats.tp;
  document.getElementById('statFP').textContent       = stats.fp;
  document.getElementById('statFN').textContent       = stats.fn;
  const avg = stats.fireStrides.length
    ? (stats.fireStrides.reduce((a,b)=>a+b,0)/stats.fireStrides.length).toFixed(1)
    : '—';
  document.getElementById('statAvgStride').textContent = avg;
}

function log(msg, cls) {
  const wrap = document.getElementById('logWrap');
  const el   = document.createElement('div');
  el.className = 'entry ' + (cls||'');
  el.textContent = msg;
  wrap.appendChild(el);
  wrap.scrollTop = wrap.scrollHeight;
  while (wrap.children.length > 100) wrap.removeChild(wrap.firstChild);
}

function showBanner(text, cls) {
  const b = document.getElementById('predictBanner');
  b.textContent = text;
  b.className   = 'predict-banner show ' + cls;
  setTimeout(() => b.className = 'predict-banner', 1000);
}

// ════════════════════════════════════════════════════════
//  SEQUENCE HELPERS
// ════════════════════════════════════════════════════════
function randomSeq()  { return Array.from({length: seqLen}, () => Math.floor(Math.random() * grades.length)); }
function targetSeq2() { return target.split('').map(c => gradeMap[c]); }

function resetForNewSeq(seq, isTarget) {
  currentSeq       = seq;
  isTargetSeq      = isTarget;
  currentStride    = 0;
  inferFiredStride = -1;
  sustainLevels    = new Array(latentNodes.length).fill(0);
  renderSeqRow(seq);
}

// ════════════════════════════════════════════════════════
//  MAIN STEP LOOP
// ════════════════════════════════════════════════════════
function step() {
  if (!running) return;

  const spd   = parseInt(document.getElementById('speed').value);
  const delay = Math.round(1000 / spd);

  // Start new sequence?
  if (currentSeq.length === 0) {
    if (seriesDone >= seriesTotal) { stopRun(); log('── series complete ──', 'sep'); return; }
    const isTgt = (seriesDone % 6 === 0);
    resetForNewSeq(isTgt ? targetSeq2() : randomSeq(), isTgt);
    stats.total++;
    updateStats();
  }

  // Process stride
  const { latentActive, inferenceFired, activeCount, window, winStart } = processStride(currentSeq, currentStride);
  const k = kInferParam();
  const n = latentNodes.length;

  // Did inference just fire?
  if (inferenceFired && inferFiredStride === -1) {
    inferFiredStride = currentStride;
    const isEarly    = currentStride < seqLen - 1;
    const isPredictive = k < n;
    if (isTargetSeq) {
      if (isEarly) {
        stats.early++;
        stats.fireStrides.push(currentStride);
        log(`[${seriesDone}] TARGET ⚡ ${isPredictive ? 'PREDICTED' : 'early fire'} at stride ${currentStride}/${seqLen-1}  (${activeCount}/${n} nodes, K=${k})`, 'early');
        showBanner(`⚡ PREDICTED stride ${currentStride}`, 'tp');
      } else {
        stats.tp++;
        stats.fireStrides.push(currentStride);
        log(`[${seriesDone}] TARGET ✓ recognised at stride ${currentStride}  (${activeCount}/${n} nodes, K=${k})`, 'tp');
        showBanner('✓ RECOGNISED', 'tp');
      }
    } else {
      stats.fp++;
      log(`[${seriesDone}] RANDOM "${currentSeq.map(g=>grades[g]).join('')}" → FP stride ${currentStride}  (${activeCount}/${n} nodes, K=${k})`, 'fp');
      showBanner('✗ FALSE POSITIVE', 'fp');
    }
    updateStats();
  }

  updateSeqRow(currentSeq, currentStride);
  drawNetwork(latentActive, window, inferenceFired);
  updateSustainBars(latentActive);

  currentStride++;

  // Sequence done?
  if (currentStride >= seqLen) {
    if (isTargetSeq && inferFiredStride === -1) {
      stats.fn++;
      log(`[${seriesDone}] TARGET MISSED → false negative`, 'fn');
      showBanner('✗ MISSED', 'fn');
      updateStats();
    }
    seriesDone++;
    currentSeq    = [];
    currentStride = 0;
    timer = setTimeout(step, delay * 3);
    return;
  }

  timer = setTimeout(step, delay);
}

function startRun() {
  if (running) return;
  resetStats();
  seriesDone  = 0;
  seriesTotal = parseInt(document.getElementById('seriesLen').value);
  currentSeq  = [];
  running     = true;
  step();
}

function stopRun() {
  running = false;
  if (timer) clearTimeout(timer);
}

// ════════════════════════════════════════════════════════
//  EVENTS
// ════════════════════════════════════════════════════════
document.getElementById('btnStart').addEventListener('click', () => { init(); startRun(); });
document.getElementById('btnStop').addEventListener('click', stopRun);
document.getElementById('btnRegen').addEventListener('click', () => { init(); });

[
  ['sensorWidth','sensorWidthVal'],
  ['fanin','faninVal'],
  ['nodeCount','nodeCountVal'],
  ['kInfer','kInferVal'],
  ['sustain','sustainVal'],
  ['speed','speedVal'],
  ['seriesLen','seriesVal'],
].forEach(([id, vid]) => {
  document.getElementById(id).addEventListener('input', e => {
    document.getElementById(vid).textContent = e.target.value;
    // keep fanin ≤ sensorWidth
    if (id === 'sensorWidth') {
      const sw = parseInt(e.target.value);
      const fi = document.getElementById('fanin');
      if (parseInt(fi.value) > sw) { fi.value = sw; document.getElementById('faninVal').textContent = sw; }
    }
    // keep K ≤ nodeCount, and nodeCount max clamps K
    if (id === 'nodeCount') {
      const nc = parseInt(e.target.value);
      const ki = document.getElementById('kInfer');
      ki.max = nc;
      if (parseInt(ki.value) > nc) { ki.value = nc; document.getElementById('kInferVal').textContent = nc; }
    }
    if (id === 'kInfer') {
      const nc = parseInt(document.getElementById('nodeCount').value);
      const kv = parseInt(e.target.value);
      if (kv > nc) { e.target.value = nc; document.getElementById('kInferVal').textContent = nc; }
    }
  });
});

window.addEventListener('load',   () => { init(); });
window.addEventListener('resize', () => { drawNetwork(sustainLevels.map(s=>s>0), [], false); });
</script>
</body>
</html>
